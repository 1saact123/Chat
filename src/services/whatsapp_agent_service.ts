/**
 * WhatsApp Generic Agent Service.
 *
 * Uses OpenAI Assistants API with function calling so the assistant can
 * autonomously detect when a customer has decided on a service and trigger
 * the switch programmatically â€” without requiring the customer to type an
 * exact number or service name.
 *
 * The assistant has one tool:
 *   select_service(service_id: string)
 *
 * When the run returns requires_action with a select_service call, this
 * service submits the tool output, collects the assistant's final confirmation
 * message, and returns { type: 'select_service', serviceId, text }.
 *
 * Thread persistence: OpenAI thread IDs are stored in
 * whatsapp_conversations.openai_thread_id so conversation history is
 * maintained across messages.
 */

import OpenAI from 'openai';
import { sequelize } from '../config/database';
import { WhatsAppConversationService } from './whatsapp_conversation_service';

export interface AgentMessage {
  type: 'message';
  text: string;
}

export interface AgentServiceSelection {
  type: 'select_service';
  serviceId: string;
  serviceName: string;
  /** Confirmation text generated by the assistant to send to the customer. */
  text: string;
}

export type AgentResult = AgentMessage | AgentServiceSelection;

export interface AvailableService {
  serviceId: string;
  serviceName: string;
}

export class WhatsAppAgentService {
  /**
   * Process a customer message with the generic WhatsApp agent.
   *
   * @param openaiToken  - OpenAI API key from the default user record
   * @param userId       - WHATSAPP_DEFAULT_USER_ID
   * @param phone        - Normalized customer phone (used to persist thread ID)
   * @param messageText  - Raw message from the customer
   * @param services     - Active services from unified_configurations (for tool enum)
   * @param existingThreadId - OpenAI thread ID from whatsapp_conversations (null = create new)
   */
  static async processMessage(
    openaiToken: string,
    userId: number,
    phone: string,
    messageText: string,
    services: AvailableService[],
    existingThreadId: string | null
  ): Promise<AgentResult> {
    const openai = new OpenAI({ apiKey: openaiToken });

    // â”€â”€ 1. Get generic assistant ID from unified_configurations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const assistantId = await this.getGenericAssistantId(userId);
    if (!assistantId) {
      console.warn('âš ï¸ WhatsApp agent: whatsapp-generic service not configured in DB. Falling back to list.');
      return { type: 'message', text: '' }; // caller handles fallback
    }

    // â”€â”€ 2. Get or create OpenAI thread â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let threadId = existingThreadId;
    if (!threadId) {
      const thread = await openai.beta.threads.create();
      threadId = thread.id;
      // Persist immediately so even if something fails the thread is saved
      await WhatsAppConversationService.updateThreadId(phone, threadId);
      console.log(`ğŸ“± [WhatsApp Agent] New thread ${threadId} for ${phone}`);
    }

    // â”€â”€ 3. Build select_service tool with dynamic service IDs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const serviceMap = new Map(services.map((s) => [s.serviceId, s.serviceName]));
    const selectServiceTool: OpenAI.Beta.Assistants.AssistantTool = {
      type: 'function',
      function: {
        name: 'select_service',
        description:
          'Call this function ONLY when the customer has clearly and explicitly decided ' +
          'which service they want. Do NOT call it when the customer is still asking questions ' +
          'or has not yet committed to a specific service.',
        parameters: {
          type: 'object',
          properties: {
            service_id: {
              type: 'string',
              enum: services.map((s) => s.serviceId),
              description: 'The service_id of the service the customer chose.'
            }
          },
          required: ['service_id']
        }
      }
    };

    // Build the services list for context
    const servicesList = services.map((s, i) => `${i + 1}. ${s.serviceName} (id: ${s.serviceId})`).join('\n');
    const additionalInstructions =
      `Servicios disponibles actualmente:\n${servicesList}\n\n` +
      `Cuando el cliente haya decidido claramente quÃ© servicio quiere, llama a la funciÃ³n select_service con el service_id correspondiente. ` +
      `Antes del switch, confirma brevemente al cliente a quÃ© servicio lo estÃ¡s conectando.`;

    // â”€â”€ 4. Add customer message to thread â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    await openai.beta.threads.messages.create(threadId, {
      role: 'user',
      content: messageText
    });

    // â”€â”€ 5. Create run with the select_service tool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let run = await openai.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
      tools: [selectServiceTool],
      additional_instructions: additionalInstructions
    });

    // â”€â”€ 6. Poll until terminal state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const MAX_POLLS = 60;
    let polls = 0;

    while (
      (run.status === 'queued' || run.status === 'in_progress' || run.status === 'requires_action') &&
      polls < MAX_POLLS
    ) {
      if (run.status === 'requires_action') {
        // â”€â”€ Function call detected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const toolCalls = run.required_action?.submit_tool_outputs?.tool_calls ?? [];
        const selectCall = toolCalls.find((tc) => tc.function.name === 'select_service');

        if (selectCall) {
          let args: { service_id?: string } = {};
          try {
            args = JSON.parse(selectCall.function.arguments || '{}');
          } catch {
            args = {};
          }

          const chosenServiceId = args.service_id ?? '';
          const chosenServiceName = serviceMap.get(chosenServiceId) ?? chosenServiceId;

          console.log(`ğŸ“± [WhatsApp Agent] select_service called: ${chosenServiceId} (${chosenServiceName})`);

          // Submit tool output so the assistant can write its final reply
          run = await openai.beta.threads.runs.submitToolOutputs(threadId, run.id, {
            tool_outputs: [
              {
                tool_call_id: selectCall.id,
                output: JSON.stringify({
                  success: true,
                  service_id: chosenServiceId,
                  service_name: chosenServiceName
                })
              }
            ]
          });

          // Wait for the run to complete after tool submission
          polls = 0;
          while (
            (run.status === 'queued' || run.status === 'in_progress') &&
            polls < MAX_POLLS
          ) {
            await new Promise((r) => setTimeout(r, 1000));
            run = await openai.beta.threads.runs.retrieve(threadId, run.id);
            polls++;
          }

          if (run.status === 'completed') {
            const msgs = await openai.beta.threads.messages.list(threadId, { limit: 1 });
            const lastMsg = msgs.data[0];
            const confirmationText =
              lastMsg?.role === 'assistant' && lastMsg.content[0]?.type === 'text'
                ? lastMsg.content[0].text.value
                : `Te conecto ahora con *${chosenServiceName}*.`;

            return {
              type: 'select_service',
              serviceId: chosenServiceId,
              serviceName: chosenServiceName,
              text: confirmationText
            };
          }

          // Run failed after tool submission
          console.error(`âŒ [WhatsApp Agent] Run ${run.id} failed after tool submission: ${run.status}`);
          return { type: 'message', text: '' };
        }

        // Unknown tool call â€“ cancel and fall through to error
        console.warn('[WhatsApp Agent] Unknown tool call, cancelling run.');
        await openai.beta.threads.runs.cancel(threadId, run.id).catch(() => {});
        return { type: 'message', text: '' };
      }

      await new Promise((r) => setTimeout(r, 1000));
      run = await openai.beta.threads.runs.retrieve(threadId, run.id);
      polls++;
    }

    // â”€â”€ 7. Collect final text response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (run.status === 'completed') {
      const msgs = await openai.beta.threads.messages.list(threadId, { limit: 1 });
      const lastMsg = msgs.data[0];
      const text =
        lastMsg?.role === 'assistant' && lastMsg.content[0]?.type === 'text'
          ? lastMsg.content[0].text.value
          : '';

      return { type: 'message', text };
    }

    console.error(`âŒ [WhatsApp Agent] Run ended with status: ${run.status}`);
    return { type: 'message', text: '' };
  }

  /** Load the assistant_id for the whatsapp-generic service from unified_configurations. */
  private static async getGenericAssistantId(userId: number): Promise<string | null> {
    const [rows] = await sequelize.query(
      `SELECT assistant_id FROM unified_configurations
       WHERE user_id = :userId AND service_id = 'whatsapp-generic' AND is_active = TRUE
       LIMIT 1`,
      { replacements: { userId } }
    ) as [any[], unknown];
    return rows?.[0]?.assistant_id ?? null;
  }
}
